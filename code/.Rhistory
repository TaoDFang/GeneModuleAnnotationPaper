ASO_data_collectio=function(input_path,output_path){
file_names=list.files(path = ASO_data_path,full.names = TRUE)
simple_file_names=unname(sapply(file_names,function(x){strsplit(x,"/")[[1]][7]}))
simple_file_names=unname(sapply(simple_file_names,function(x){strsplit(x,split = "\\.")[[1]][1]}))
file1=read.csv(file_names[[1]],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
#orthologue_geneInfo=annotateAnyIDs(file1$GeneID,orthologue = TRUE)
nonEmptyRows=!is.na(file1$GeneSymbol)
file1=file1[nonEmptyRows,]
files=list()
for(i in 1:length(file_names)){
files[[i]]=read.csv(file_names[i],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
nonEmptyRows=!is.na(files[[i]]$GeneSymbol)
files[[i]]=files[[i]][nonEmptyRows,]
}
ASO_DEG=data.frame(matrix(NA,nrow = 6,ncol = nrow(files[[1]])),row.names = simple_file_names)
colnames(ASO_DEG)=files[[1]]$GeneSymbol
for(i in 1:length(file_names)){
ASO_DEG[i,]=files[[i]][match(files[[i]]$GeneSymbol,colnames(ASO_DEG)),"logFC"]
}
write.csv(ASO_DEG,file ="~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liver/ASO_DEG.csv",row.names = TRUE,col.names = TRUE,sep = ",")
}
ASO_data_collection=function(input_path,output_path){
file_names=list.files(path = ASO_data_path,full.names = TRUE)
simple_file_names=unname(sapply(file_names,function(x){strsplit(x,"/")[[1]][7]}))
simple_file_names=unname(sapply(simple_file_names,function(x){strsplit(x,split = "\\.")[[1]][1]}))
file1=read.csv(file_names[[1]],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
#orthologue_geneInfo=annotateAnyIDs(file1$GeneID,orthologue = TRUE)
nonEmptyRows=!is.na(file1$GeneSymbol)
file1=file1[nonEmptyRows,]
files=list()
for(i in 1:length(file_names)){
files[[i]]=read.csv(file_names[i],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
nonEmptyRows=!is.na(files[[i]]$GeneSymbol)
files[[i]]=files[[i]][nonEmptyRows,]
}
ASO_DEG=data.frame(matrix(NA,nrow = 6,ncol = nrow(files[[1]])),row.names = simple_file_names)
colnames(ASO_DEG)=files[[1]]$GeneSymbol
for(i in 1:length(file_names)){
ASO_DEG[i,]=files[[i]][match(files[[i]]$GeneSymbol,colnames(ASO_DEG)),"logFC"]
}
write.csv(ASO_DEG,file ="~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liver/ASO_DEG.csv",row.names = TRUE,col.names = TRUE,sep = ",")
}
input_path = ASO_data_removeOutlier_path
ASO_data_path="~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liver"
ASO_data_removeOutlier_path="~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liverRemoveOutlier"
input_path = ASO_data_removeOutlier_path
output_path = "~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liver/ASO_removeOutlier_DEG.csv"
file_names=list.files(path = input_path,full.names = TRUE)
simple_file_names=unname(sapply(file_names,function(x){strsplit(x,"/")[[1]][7]}))
simple_file_names=unname(sapply(simple_file_names,function(x){strsplit(x,split = "\\.")[[1]][1]}))
file1=read.csv(file_names[[1]],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
View(file1)
View(file1)
ASO_data_collection=function(input_path,output_path){
file_names=list.files(path = input_path,full.names = TRUE)
simple_file_names=unname(sapply(file_names,function(x){strsplit(x,"/")[[1]][7]}))
simple_file_names=unname(sapply(simple_file_names,function(x){strsplit(x,split = "\\.")[[1]][1]}))
file1=read.csv(file_names[[1]],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
#orthologue_geneInfo=annotateAnyIDs(file1$GeneID,orthologue = TRUE)
nonEmptyRows=!is.na(file1$GeneSymbol)
file1=file1[nonEmptyRows,]
files=list()
for(i in 1:length(file_names)){
files[[i]]=read.csv(file_names[i],sep = "\t",header = TRUE,stringsAsFactors = FALSE)
nonEmptyRows=!is.na(files[[i]]$GeneSymbol)
files[[i]]=files[[i]][nonEmptyRows,]
}
ASO_DEG=data.frame(matrix(NA,nrow = 6,ncol = nrow(files[[1]])),row.names = simple_file_names)
colnames(ASO_DEG)=files[[1]]$GeneSymbol
for(i in 1:length(file_names)){
ASO_DEG[i,]=files[[i]][match(files[[i]]$GeneSymbol,colnames(ASO_DEG)),"logFC"]
}
write.csv(ASO_DEG,file =output_path,row.names = TRUE,col.names = TRUE,sep = ",")
}
ASO_data_collection(input_path = ASO_data_removeOutlier_path,output_path = "~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liver/ASO_removeOutlier_DEG.csv")
ASO_data_collection(input_path = ASO_data_removeOutlier_path,output_path = "~/Documents/MasterThesis_Data/201507ratLNA-edgeR-liverRemoveOutlier/ASO_removeOutlier_DEG.csv")
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Documents/team_taofang/")
cwd="~/Documents/team_taofang/"
library(xlsx)
library(refGenome)
library(monocle)
library(SummarizedExperiment)
# load RNA-seq counts from patients with NAFLD
human_counts=read.csv(file =paste(cwd,"Hisat2_Counts.tsv",sep = ""),sep = "\t",header = TRUE )
# read group information from patients with NAFLD
# 1: NAFL, 2: NASH and 3: NASH-Cirrhosis
human_groups=read.xlsx(file = paste(cwd,"Allison_NASH_Official_Clinical_Database_24_02_2018_-_Seq Only.xlsx",sep = ""),sheetIndex = 4)
# read meta information from patients with NAFLD
human_meta=read.xlsx(file = paste(cwd,"Allison_NASH_Official_Clinical_Database_24_02_2018_-_Seq Only.xlsx",sep = ""),sheetIndex = 1,stringsAsFactors = FALSE)
human_meta[,"General.groups"]=human_groups[match(human_meta$SeqID,human_groups$SeqID),"General.groups"]
Human_SeqID=human_meta$SeqID
human_sim_SeqID=unname(sapply(Human_SeqID,function(x){temp=strsplit(x,split = "\\-")[[1]][c(3,4)]
paste(temp[1],temp[2],sep = ".")}))
human_sim_SeqID=sapply(human_sim_SeqID,function(x){substr(x,1,18)})
rownames(human_meta)=human_sim_SeqID
human_meta=human_meta[colnames(human_counts),]
#read grf/annotation file
#https://davetang.org/muse/2017/08/04/read-gtf-file-r/
# human_gtf_ens=ensemblGenome()
# read.gtf(human_gtf_ens, paste(cwd,"reference/Homo_sapiens.GRCh38.83.gtf",sep = ""),useBasedir = FALSE)
# human_gtf_gene <- getGenePositions(human_gtf_ens)
# human_gtf_length=data.frame(matrix(,nrow = nrow(human_gtf_gene),ncol = 2),row.names = human_gtf_gene$gene_id)
# colnames(human_gtf_length)=c("gene_id","length")
# human_gtf_length[,"gene_id"]=human_gtf_gene$gene_id
# human_gtf_length[,"length"]=human_gtf_gene$end-(human_gtf_gene$start)
# write.csv(human_gtf_gene,file = paste(cwd,"reference/human_gtf_gene.csv",sep = ""),sep = ",")
# write.csv(human_gtf_length,file = paste(cwd,"reference/human_gtf_length.csv",sep = ""),sep = ",")
human_gtf_length=read.csv(file =paste(cwd,"reference/human_gtf_length.csv",sep = "") ,sep = ",",row.names = 1,header = TRUE)
human_gtf_gene=read.csv(file =paste(cwd,"reference/human_gtf_gene.csv",sep = "") ,sep = ",",header = TRUE)
rownames(human_gtf_gene)=human_gtf_gene$gene_id
human_gtf_gene=human_gtf_gene[rownames(human_counts),]
human_gtf_length=human_gtf_length[rownames(human_counts),]
human_tpm=simple_TPM(counts = human_counts,length = human_gtf_length$length)
simple_TPM=function(counts,length){
x <- counts / length
tpm.mat <- t( t(x) * 1e6 / colSums(x) )
}
human_gtf_length=human_gtf_length[rownames(human_counts),]
human_tpm=simple_TPM(counts = human_counts,length = human_gtf_length$length)
##monocle
human_pd<- new("AnnotatedDataFrame", data = human_meta)
human_fd <- new("AnnotatedDataFrame", data = human_gtf_gene)
human_HSMM <- newCellDataSet(human_tpm,
phenoData = human_pd, featureData = human_fd,
expressionFamily = tobit())
#human_HSMM  <- estimateSizeFactors(human_HSMM )
#disp_table <- dispersionTable(human_HSMM )
unsup_clustering_genes <- rownames(human_tpm)[rowMeans(human_tpm)>0.1]
unsup_clustering_genes <- rownames(human_tpm)[rowMeans(human_tpm)>0.3]
unsup_clustering_genes <- rownames(human_tpm)[rowMeans(human_tpm)>1]
unsup_clustering_genes <- rownames(human_tpm)[rowMeans(human_tpm)>3]
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
unsup_clustering_genes <- rownames(human_tpm)[rowMeans(human_tpm)>10]
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
HSMM <- reduceDimension(HSMM,reduction_method = "ICA", max_components = 2, verbose = T)
plot_cell_clusters(HSMM_clusters, 1, 2, color = "General.groups")
HSMM_clusters <- clusterCells(HSMM, num_clusters = 3)
HSMM_clusters <- clusterCells(HSMM, num_clusters = 3)
HSMM_clusters <- clusterCells(HSMM, num_clusters = 2)
help("clusterCells")
HSMM@reducedDimS
HSMM_clusters <- clusterCells(HSMM, num_clusters = 2)
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
HSMM <- reduceDimension(HSMM,reduction_method = "ICA", max_components = 2, verbose = T)
HSMM_clusters <- clusterCells(HSMM, num_clusters = 2)
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
HSMM <- reduceDimension(HSMM,reduction_method = "ICA", max_components = 2, verbose = T)
HSMM <- reduceDimension(HSMM,reduction_method = "ICA", max_components = 2, verbose = T)
HSMM_clusters <- clusterCells(HSMM, num_clusters = 2)
HSMM_clusters <- clusterCells(HSMM, num_clusters = 2)
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
HSMM <- reduceDimension(HSMM,reduction_method = "tSNE", max_components = 2, verbose = T)
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
HSMM <- reduceDimension(HSMM,reduction_method = "tSNE", max_components = 2, num_dim=10,verbose = T)
HSMM <- reduceDimension(HSMM,reduction_method = "tSNE", max_components = 2, num_dim=100,verbose = T)
HSMM <- setOrderingFilter(human_HSMM, unsup_clustering_genes)
HSMM <- reduceDimension(HSMM,reduction_method = "ICA", max_components = 2, num_dim=10,verbose = T)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("TSCAN", version = "3.8")
source("https://bioconductor.org/biocLite.R")
BiocInstaller::biocLite("TSCAN")
library(TSCAN)
help("preprocess")
procdata <- preprocess(human_tpm)
View(procdata)
lpsmclust <- exprmclust(procdata)
plotmclust(lpsmclust)
human_groups
lpsorder <- TSCANorder(lpsmclust)
lpsorder
View(human_groups)
diffval <- difftest(procdata,lpsorder)
head(row.names(diffval)[diffval$qval < 0.05])
help("exprmclust")
help("plotmclust")
lpsorder
View(human_groups)
plotmclust(lpsmclust)
procdata <- preprocess(human_tpm)
lpsmclust <- exprmclust(procdata,clusternum = 3)
plotmclust(lpsmclust)
lpsm_dim=lpsmclust$clusterid
lpsm_dim=
lpsmclust$clusterid
lpsmclust$clusterid
order(lpsmclust$clusterid)
names(lpsmclust$clusterid)
names(lpsmclust$clusterid)[lpsmclust$clusterid==1]
names(lpsmclust$clusterid)[lpsmclust$clusterid==3]
names(lpsmclust$clusterid)[lpsmclust$clusterid==2]
names(lpsmclust$clusterid)[lpsmclust$clusterid==3]
order(names(lpsmclust$clusterid)[lpsmclust$clusterid==3])
names(lpsmclust$clusterid)[lpsmclust$clusterid==3]
overlap(names(lpsmclust$clusterid)[lpsmclust$clusterid==1],human_meta[human_meta$General.groups==1,"SeqID"])
overlap(names(lpsmclust$clusterid)[lpsmclust$clusterid==1],human_meta[human_meta[,"General.groups"]==1,"SeqID"])
human_meta[,"General.groups"]==1
human_meta[human_meta[,"General.groups"]==1,"SeqID"])
human_meta[human_meta[,"General.groups"]==1,"SeqID"]
names(lpsmclust$clusterid)[lpsmclust$clusterid==1]
View(human_meta)
intersect(names(lpsmclust$clusterid)[lpsmclust$clusterid==1],rownames(human_meta)[human_meta[,"General.groups"]==1])
intersect(names(lpsmclust$clusterid)[lpsmclust$clusterid==2],rownames(human_meta)[human_meta[,"General.groups"]==2])
intersect(names(lpsmclust$clusterid)[lpsmclust$clusterid==3],rownames(human_meta)[human_meta[,"General.groups"]==3])
rm(list = ls())
rm(list = ls())
R.version
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install(version="devel")
BiocManager::valid()
BiocManager::version()
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
install.packages("BiocManager")
install.packages("BiocManager")
BiocManager::install(version="devel")
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install(version="devel")
BiocManager::valid()
BiocManager::version()
BiocManager::install(version="devel")
BiocManager::valid()
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install(version = "devel")
BiocManager::valid()              # checks for out of date packages
R.version
BiocManager::install("GENEMABR")
BiocManager::install("GENEMABR")
help(rm(list = ls*()))
help(rm(list = ls()))
knitr::opts_chunk$set(echo = TRUE)
library(devtools)
library(devtools)
library(roxygen2)
knitr::opts_chunk$set(echo = TRUE)
library(roxygen2)
library(devtools)
rm(list = ls())
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
a=read.csv(file = "../../../6_module_functional_annotation/2_functional_enrichment/dream_consensus_modules.functional_enrichment.txt",header = T,sep = "\t")
head(a)
hypergeometric_test_results=read.csv(file = "../inst/extdata/Daniel_S5_mod283.txt",header = T,sep = "\t")
hypergeometric_test_results$module
b=a[a$module=="PPI-InWeb_Consensus_mod283",]
hypergeometric_test_results=read.csv(file = "../inst/extdata/Daniel_S5_mod283.txt",header = T,sep = "\t")
View(hypergeometric_test_results)
View(b)
hypergeometric_test_results=read.csv(file = "../inst/extdata/Daniel_S5_mod283.txt",header = T,sep = "\t")
View(hypergeometric_test_results)
colnames(hypergeometric_test_results)
gene_list=c("TRPC4AP","CDC37","TNIP1","IKBKB","NKIRAS2","NFKBIA","TIMM50","RELB","TNFAIP3","NFKBIB","HSPA1A","NFKBIE","SPAG9","NFKB2","ERLIN1","REL","TNIP2","TUBB6","MAP3K8")
help("regression_selected_pathways")
enrichment_results=regression_selected_pathways(gene_input=gene_list,gene_pathway_matrix="default",alpha=0.5)
regression_selected_pathways=function(gene_input,gene_pathway_matrix="default",lambda=0.007956622,alpha=0.5,...){
library(glmnet)
addi_args=list(...)
if(gene_pathway_matrix=="default"){
gene_pathway_matrix=readRDS(system.file("extdata", "gene_pathway_matrix.rds", package = "GENEMABR"))
}
all_genes=rownames(gene_pathway_matrix)
all_pathways=colnames(gene_pathway_matrix)
module_labels=rep(0,length(all_genes))          #len:20244F
names(module_labels)=all_genes
module_common_genes=intersect(all_genes,gene_input)
if(length(module_common_genes)>1){                     # should set a lower thereshold for num of module common genes, more than 50%
module_labels[module_common_genes]=1
if(length(addi_args)==0){
cvfit=glmnet(gene_pathway_matrix,module_labels,lambda = lambda,alpha =alpha,...)
}else{
cvfit=glmnet(gene_pathway_matrix,module_labels,alpha =alpha,...)
}
coef=coef(cvfit, s = "lambda.min")
non0index=coef@i[-1]   #remove intercept
non0coef=coef@x[-1]
selected_index=non0index[which(non0coef>0)]
selected_pathways=all_pathways[selected_index]
selected_coef=non0coef[which(non0coef>0)]
names(selected_coef)=selected_pathways
if(length(selected_pathways)>0){
fisher_exact_test_results=fisher_exact_test(selected_pathways,module_common_genes,gene_pathway_matrix="default" )
selected_pathways_fisher_pvalue=fisher_exact_test_results$selected_pathways_fisher_pvalue
selected_pathways_num_genes=fisher_exact_test_results$selected_pathways_num_genes
new_order=order(selected_coef,decreasing = TRUE)
return(list(selected_pathways_names=from_id2name(selected_pathways=names(selected_coef[new_order])),
selected_pathways_coef=selected_coef[new_order],
selected_pathways_fisher_pvalue=selected_pathways_fisher_pvalue[new_order],
selected_pathways_num_genes=selected_pathways_num_genes[new_order]
))
}else{
return(NULL)}
}
}
enrichment_results=regression_selected_pathways(gene_input=gene_list,gene_pathway_matrix="default",alpha=0.5)
enrichment_results=regression_selected_pathways(gene_input=gene_list,gene_pathway_matrix="default",alpha=0.5)
#' fisher_exact_test
#'
#' This function allows you to compute two sided fish exact pvalue of gene list for selected  pathways
#' To know more about this method. I recommend you to read the paper (Enrichment or depletion of a GO category within a class of genes: which test?) for more details
#' @param selected_pathways A vecor of pathways to be used for enrichment analysis for genes in \emph{gene_input}.It should have same ID types(E.g. pathway ID, pathway names) as the pathways in \emph{gene_pathway_matrix}.
#' @param gene_input A vecor of genes to be annotated. It should have same ID types(E.g. Ensembl ID, HUGO gene symbol) as the genes in \emph{gene_pathway_matrix}.
#' @param gene_pathway_matrix A binary background matrix whose columns are the pathways/gene sets and
#'whose rows are all the genes from pathways/gene sets . It could be in sparse matrix format ((inherit from class "sparseMatrix" as in package Matrix) to save memory.
#'For gene i and pathway j, the value of matrix(i,j) is 1 is gene i belonging to pathway j otherwise 0.
#'Users could leave it as default value("default") so it will use pre-collected gene_pathway_matrix from GO Ontology and REACTOME databaase.
#'Otherwise, they could use their own customized gene_pathway_matrix
#' @return  A list of two elements:
#' \itemize{
#'   \item selected_pathways_fisher_pvalue - Fisher exact pvalue for selected pathways
#'   \item selected_pathways_num_genes - The number of genes for selected pathways in background
#' }
#' @keywords
#' @export
#' @examples
#' a=fisher_exact_test(selected_pathways=c("GO:0007250","GO:0008625"),gene_input=c("TRPC4AP","CDC37","TNIP1","IKBKB","NKIRAS2","NFKBIA","TIMM50","RELB","TNFAIP3","NFKBIB","HSPA1A","NFKBIE","SPAG9","NFKB2","ERLIN1","REL","TNIP2","TUBB6","MAP3K8"),gene_pathway_matrix="default")
fisher_exact_test=function(selected_pathways,gene_input,gene_pathway_matrix="default"){
if(gene_pathway_matrix=="default"){
gene_pathway_matrix=readRDS(system.file("extdata", "gene_pathway_matrix.rds", package = "GENEMABR"))
}
all_genes=rownames(gene_pathway_matrix)
module1_common_genes=intersect(all_genes,gene_input)
selected_pathways_fisher_pvalue=vector()
selected_pathways_num_genes=vector()
for(index in 1:length(selected_pathways)){
fisher_pathway=selected_pathways[index]
#          genes_in_common      genes_in_reference
#pathway          a                   c
#no_pathway       b                   d
a=sum(gene_pathway_matrix[module1_common_genes,fisher_pathway])
b=length(module1_common_genes)-a
c=sum(gene_pathway_matrix[,fisher_pathway])-a
d=length(all_genes)-a-c-b
contigency_table=matrix(c(a,b,c,d),nrow = 2)
fisher_result=fisher.test(contigency_table)
selected_pathways_fisher_pvalue[fisher_pathway]=fisher_result[['p.value']]
selected_pathways_num_genes[fisher_pathway]=sum(gene_pathway_matrix[,fisher_pathway])
}
return(list(selected_pathways_fisher_pvalue=selected_pathways_fisher_pvalue,selected_pathways_num_genes=selected_pathways_num_genes))
}
#' find_root_ids
#'
#' If you use the default pathway databases(GO Ontologyand REACTOME),this function allows you to extract GO sub-roots or REACTOME roots for certain pathways from GO or REACTOME
#' to help you better understanding thier the biological meanings
#' @param selected_pathways A vecor of GO and/or REACTOME pathways IDs.
#' @return  A list of GO sub-root or REACTOME root ids for provided pathways.
#' If a certain pathway has morn than one GO sub-roots or REACTOME roots, they will be seperated by "#".
#' @keywords
#' @export
#' @examples
#' find_root_ids(selected_pathways=c("GO:0005834","R-HSA-111469"))
find_root_ids=function(selected_pathways){
go_ontology=readRDS(system.file("extdata", "human_go_ontology.rds", package = "GENEMABR"))
go_sub_roots=readRDS(system.file("extdata", "human_go_sub_roots.rds", package = "GENEMABR"))
go_sub_roots=unlist(go_sub_roots)
reactome_ontology=readRDS(system.file("extdata", "human_reactome_ontology.rds", package = "GENEMABR"))
reactome_roots=readRDS(system.file("extdata", "human_reactome_roots.rds", package = "GENEMABR"))
find_roots=lapply(selected_pathways, function(x){
if(grepl("GO",x)){
parent_nodes=ego(go_ontology,order = gorder(go_ontology),x,mode = "in")
find_roots=intersect(go_sub_roots,names(unlist(parent_nodes)))
}else{
parent_nodes=ego(reactome_ontology,order = gorder(reactome_ontology),x,mode = "in")
find_roots= intersect(reactome_roots,names(unlist(parent_nodes)))
}
if(length(find_roots)>1){
find_roots=paste0(unlist(find_roots),collapse = "#")
}
return(find_roots)
})
names(find_roots)=selected_pathways
return(find_roots)
}
#' from_id2name
#'
#' If you use the default pathway databases(GO Ontologyand REACTOME),this function can help you to get pathways names from pathways IDs.
#' @param selected_pathways A list of GO and/or REACTOME pathways IDs. Each elmment is this list can be a single id or multi-ids seperated "#"
#' @return  A list of GO sub-root or REACTOME root names for provided pathways.
#' @keywords
#' @export
#' @examples
#' from_id2name((selected_pathways=list(c("GO:0032991#GO:0044425#GO:0044464"),"R-HSA-5357801")))
from_id2name=function(selected_pathways){
go_ontology=readRDS(system.file("extdata", "human_go_ontology.rds", package = "GENEMABR"))
reactome_ontology=readRDS(system.file("extdata", "human_reactome_ontology.rds", package = "GENEMABR"))
go_ontology_names=V(go_ontology)$pathway_names
names(go_ontology_names)=as_ids(V(go_ontology))
reactome_ontology_names=V(reactome_ontology)$pathway_names
names(reactome_ontology_names)=as_ids(V(reactome_ontology))
names=lapply(selected_pathways, function(x){
if(grepl("#",x)){
if(grepl("GO",x)){
y=strsplit(x,split = "#")[[1]]
unname(go_ontology_names[y])
}else{
y=strsplit(x,split = "#")[[1]]
unname(reactome_ontology_names[y])
}
}else{
if(grepl("GO",x)){
unname(go_ontology_names[x])
}else{
unname(reactome_ontology_names[x])
}
}
})
names(names)=selected_pathways
return(names)
}
#' get_steps
#'
#' If you use the default pathway databases(GO Ontologyand REACTOME),this function allows you to extract  the distances from ceatain pathways to  GO roots or REACTOME roots nodes.
#' @param selected_pathways A vecor of GO and/or REACTOME pathways IDs.
#' @return  A list contains distances from pathways to GO root or REACTOME root nodes
#' @keywords
#' @export
#' @examples
#' get_steps(selected_pathways=c("GO:0005834","R-HSA-111469"))
get_steps=function(selected_pathways){
go_ontology=readRDS(system.file("extdata", "human_go_ontology.rds", package = "GENEMABR"))
go_roots=readRDS(system.file("extdata", "human_go_roots.rds", package = "GENEMABR"))
go_roots=unlist(go_roots)
reactome_ontology=readRDS(system.file("extdata", "human_reactome_ontology.rds", package = "GENEMABR"))
reactome_roots=readRDS(system.file("extdata", "human_reactome_roots.rds", package = "GENEMABR"))
steps=lapply(selected_pathways,function(x){
if(grepl("GO",x)){
min(distances(go_ontology,v=go_roots,to=x))
}else{
min(distances(reactome_ontology,v=reactome_roots,to=x))
}
})
return(steps)
}
enrichment_results=regression_selected_pathways(gene_input=gene_list,gene_pathway_matrix="default",alpha=0.5)
library(igraph)
enrichment_results=regression_selected_pathways(gene_input=gene_list,gene_pathway_matrix="default",alpha=0.5)
enrichment_results=regression_selected_pathways(gene_input=gene_list,gene_pathway_matrix="default",alpha=0.5)
enrichment_results
enrichment_results$selected_pathways_names
colnames(hypergeometric_test_results)
hypergeometric_test_results_filtered=hypergeometric_test_results[hypergeometric_test_results$P.noncentral<0.05,]
dim(hypergeometric_test_results_filtered)
enrichment_results
enrichment_results$selected_pathways_names
enrichment_results
enrichment_results$selected_pathways_names
sessionInfo()
enrichment_results
enrichment_results$selected_pathways_names
GO_Reactome_root_id=find_root_ids(selected_pathways=c("GO:0005834","R-HSA-111469"))
GO_Reactome_root_id_names=from_id2name(GO_Reactome_root_id)
enrichment_results$selected_pathways_coef
GO_Reactome_root_id=find_root_ids(selected_pathways=names(enrichment_results$selected_pathways_coef))
GO_Reactome_root_id
GO_Reactome_root_id_names=from_id2name(GO_Reactome_root_id)
GO_Reactome_root_id_names
step2root=get_steps(selected_pathways=c("GO:0005834","R-HSA-111469"))
step2root=get_steps(selected_pathways=names(enrichment_results$selected_pathways_coef))
step2root
get_steps=function(selected_pathways){
go_ontology=readRDS(system.file("extdata", "human_go_ontology.rds", package = "GENEMABR"))
go_roots=readRDS(system.file("extdata", "human_go_roots.rds", package = "GENEMABR"))
go_roots=unlist(go_roots)
reactome_ontology=readRDS(system.file("extdata", "human_reactome_ontology.rds", package = "GENEMABR"))
reactome_roots=readRDS(system.file("extdata", "human_reactome_roots.rds", package = "GENEMABR"))
steps=lapply(selected_pathways,function(x){
if(grepl("GO",x)){
min(distances(go_ontology,v=go_roots,to=x))
}else{
min(distances(reactome_ontology,v=reactome_roots,to=x))
}
})
names(selected_pathways)
return(steps)
}
step2root=get_steps(selected_pathways=names(enrichment_results$selected_pathways_coef))
step2root
get_steps=function(selected_pathways){
go_ontology=readRDS(system.file("extdata", "human_go_ontology.rds", package = "GENEMABR"))
go_roots=readRDS(system.file("extdata", "human_go_roots.rds", package = "GENEMABR"))
go_roots=unlist(go_roots)
reactome_ontology=readRDS(system.file("extdata", "human_reactome_ontology.rds", package = "GENEMABR"))
reactome_roots=readRDS(system.file("extdata", "human_reactome_roots.rds", package = "GENEMABR"))
steps=lapply(selected_pathways,function(x){
if(grepl("GO",x)){
min(distances(go_ontology,v=go_roots,to=x))
}else{
min(distances(reactome_ontology,v=reactome_roots,to=x))
}
})
names(steps)=selected_pathways
return(steps)
}
step2root=get_steps(selected_pathways=names(enrichment_results$selected_pathways_coef))
step2root
# steps to procees documentation for the pacakge
setwd("~/Documents/GeneModuleAnnotationPaper/code/GENEMABR")
document()
setwd("~/Documents/GeneModuleAnnotationPaper/code")
install("GENEMABR")
library(GENEMABR)
library(devtools)
library(roxygen2)
# steps to procees documentation for the pacakge
setwd("~/Documents/GeneModuleAnnotationPaper/code/GENEMABR")
document()
setwd("~/Documents/GeneModuleAnnotationPaper/code")
install("GENEMABR")
library(GENEMABR)
